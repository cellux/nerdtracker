# NerdTracker

NerdTracker is a music tracker for programmers.

## Glossary

| term | acronym | description |
| ---- | ------- | ----------- |
| advance direction | `ADI` | The direction in which the edit cursor moves after entering a digit in the sequencer or pattern editor. |
| audio buffer size | `ABS` | Number of sample frames generated by the audio callback during one invocation. |
| audio callback | `ACB` | A function periodically invoked by the OS audio subsystem to generate a fixed number of sample frames for playback. |
| beats per row | `BPR` | Determines the number of beats associated with a single row in the sequencer. The higher the BPR, the less vertical space is needed to track a particular amount of music. |
| beats per minute | `BPM` | Number of beats (quarter notes) per minute. |
| bus | `BUS` | A special instrument with a single voice that is always active. When playback begins, each bus instrument is instantiated and the resulting voices are added to the list of active buses. During playback, the audio engine sends `render` messages to all active voices and then to all active buses (in the order of their instrument numbers). A typical use of bus instruments is to apply effects to the mixed output of several voices as a whole. |
| byte | `BYT` | An unsigned integer between 0-255 (00-FF). Some opcodes interpret a byte parameter as a signed integer in two's complement representation with the range -128-+127 (80-7F). |
| channel | `CHN` | A column of the pattern matrix. |
| channel voice | `CVC` | The current voice (instrument instance) playing on a channel. |
| controller | `CTL` | A tuple of a register index (0-F) and a register value (00-FF). Used to update a register of the current channel voice or track phrase. |
| controller lane | `TLN` | A lane which contains controllers. |
| float | `FLT` | IEEE754 single-precision 32-bit floating point number. |
| instrument | `INS` | Contains an instrument program and default values for the instrument's instances (voices). May also contain a list of arbitrarily sized byte or float arrays shared by all voices of the instrument. |
| instrument id | | An integer between 00-FF. Instrument 00 is a special hard-wired bus instrument whose first N output buffers are used to fill the audio buffer of the sound card (N is the number of audio output channels). |
| instrument instance | | Alternative term for *voice*. |
| instrument program | `PRG` | A series of opcodes, executed in order when a voice is asked to generate sample frames for the current tick. The configurations of opcode inputs and outputs (i.e. literal values and/or register references) are also part of the program. |
| lane | `LAN` | A column in the sequencer or pattern editor which may contain pattern ids, instrument ids, triggers or controllers. |
| lines per beat | `LPB` | Determines the number of lines shown for each beat in the pattern editor. Must be a divisor of TPB. The higher the LPB, the greater the precision with which you can sculpt the music. Each pattern may have its own LPB. |
| matrix | `MAT` | The grid of cells that form rows/lines and columns in the sequencer and the pattern editor. |
| mnemonic | `NAM` | A three-letter identifier. |
| opcode | `OP` | Identifies a virtual machine instruction with N inputs and M outputs. |
| opcode argument | `ARG` | An input or output of a virtual machine instruction. Inputs and outputs may be scalars or arrays of bytes (`BYT`) or floats (`FLT`). A scalar argument may be a literal value (for bytes) or a reference to a register of the currently executing voice, instrument phrase, pattern song or sequencer. An array argument can only be a register reference. |
| pattern | `PAT` | A matrix of pattern cells organized into lines and channels. |
| pattern cell | `PCL` | The element stored in one row of a pattern channel. May contain an instrument id (00-FF) and any number of triggers or controllers. The instrument id (if set) creates a new voice and sets it as current for the channel. Triggers and controllers can be used to send signals to or update registers of the current channel voice. |
| pattern id | | An integer between 000-FFF. |
| pattern instance | | Alternative term for *phrase*. |
| phrase | `PSE` | Contains a reference to a pattern, a tick counter and a register file. Byte and float registers are initialized from defaults stored in the pattern. The contents of byte and float arrays are undefined when a phrase starts. |
| register | `REG` | A contiguous array of bytes in memory which can be used to store a byte, a float or an array of bytes or floats. The following objects have registers: voices, instruments, phrases, patterns, the song and the sequencer. |
| register file | `RFL` | A structure which contains 32 byte registers, 32 float registers and any number of arbitrarily sized arrays with byte or float values. |
| register reference | `REF` | Contains a target (v: current voice, V: current instrument, p: current phrase, P: current pattern, s: the song, S: the sequencer) and a register index (00-1F for bytes and floats, the index of an existing slot for arrays). Opcode inputs and outputs inside an instrument program are either literal values or register references. |
| sample | `SMP` | IEEE754 single-precision 32-bit floating point number, typically in the range [-1,1]. |
| sample buffer | `BUF` | An array of at least TBS samples. |
| sample frame | `SF` | A bundle of N samples where N is the number of audio channels. |
| sample rate | `SR` | Number of sample frames per second. |
| sequencer | `SEQ` | A matrix of sequencer cells organized into rows and tracks. |
| sequencer cell | `SCL` | The element stored in one row of a sequencer track. May contain a pattern id (000-FFF) and any number of triggers or controllers. The pattern id (if set) creates a new phrase and sets it as current for the track. Triggers and controllers can be used to send signals to or update registers of the current track phrase. |
| song | `SNG` | Contains a reference to the sequencer, a tick counter and a register file. Byte and float registers are initialized from defaults stored in the sequencer. The contents of byte and float arrays are undefined when the song starts. |
| tick | `TIK` | Each beat is divided into TPB ticks. The audio engine creates new voices/phrases and updates the parameters of existing ones at tick boundaries. |
| tick buffer size | `TBS` | Number of sample frames generated by a voice during one tick. |
| ticks per beat | `TPB`| Determines the "resolution" of the music, i.e. the frequency of ticks. The higher the TPB, the greater the resolution (and the CPU usage). The TPB also restricts the possible values of the LPB (lines per beat) pattern parameter. |
| track | `TRK` | A column of the sequencer matrix. |
| track phrase | `TSE` | The current phrase (pattern instance) playing on a track. |
| trigger | `TRG` | A signal identified by an integer between 0-F which can be sent to voices or phrases. |
| trigger lane | `TLN` | A lane which contains trigger values (0-F). |
| virtual machine | `VM` | A virtual machine running inside the tracker which can execute opcodes (VM instructions). |
| voice | `VOC` | A particular instance of an instrument. Each voice has 32 byte registers, 32 float registers, plus a preconfigured number of byte or float arrays of arbitrary size. Byte and float registers are initialized from defaults stored in the instrument. The contents of arrays are undefined when a voice starts but their size is known (specified by the instrument). The instrument program is shared by all voices of an instrument. When the tracker allocates a new voice for an instrument, each opcode inside the instrument program gets its own voice-specific state (e.g. current phase for an oscillator, current stage of an ADSR envelope, etc.). The configuration of the opcode inputs and outputs (i.e. their literal value or the index of the register to which they are bound) is shared by all voices, but the values of the registers referenced by these inputs/outputs are stored separately per voice. |

## Prototypes and instances

A *prototype* defines:

- a three letter mnemonic (NAM)
- a one line description
- the max number of simultaneous instances (PHY)
- the number and size of byte arrays per instance
- the number and size of float arrays per instance
- default values for the 32 byte/float registers
- an array of pointers to byte arrays
- an array of pointers to float arrays
- a pool of pre-allocated instances (1..PHY)

Examples of prototypes are instruments, patterns and the sequencer.

An *instance* contains the following items:

- a pointer to the prototype
- 32 byte registers
- 32 float registers
- an array of pointers to byte arrays
- an array of pointers to float arrays
- any additional data specific to the instance

Examples of instances are voices, phrases and the song.

### Instruments and voices

Extra data for an instrument:

- instrument program: a series of opcodes and their input/output arguments
- bus: if true, this instrument is a bus (has a single voice that is always active)

Extra data for a voice:

- an array of pointers to opcode states (one state structure per opcode)

When an instrument id appears in a pattern cell, the audio engine:

1. takes a free voice V from the instrument's voice pool
2. copies default values of byte/float registers from the instrument into V
3. executes any register writes specified by controllers in the pattern cell
5. sends any signals specified by triggers in the pattern cell (left to right)
4. adds V to the tracker's list of active voices

### Patterns and phrases

When a pattern id appears in a sequencer cell, the audio engine:

1. takes a free phrase P from the patterns's phrase pool
2. copies default values of byte/float registers from the pattern into P
3. executes any register writes specified by controllers in the sequencer cell
5. sends any signals specified by triggers in the sequencer cell (left to right)
4. adds P to the tracker's list of active phrases

The user does not have to specify the length of patterns. The audio engine searches for the last non-empty line and automatically removes any pattern phrase from the active list when it ticks beyond that line.

### Sequencer and song

When the user starts or resumes playing in the sequencer, the audio engine:

1. allocates a free song S from the sequencer's song pool
2. copies default values of byte/float registers from the sequencer into S
3. sets S as the tracker's active song
4. clears the list of active voices and buses
5. instantiates all buses and adds the resulting voices to the tracker's list of active buses

When the user stops playing, the audio engine:

1. clears the tracker's list of active phrases
2. clears the tracker's active song
3. sends a release signal (0) to all active voices

When all active voices end, the audio engine waits for a couple of seconds and then clears the list of active buses as well.

## Tracker

- abs (int): audio buffer size
- acb (Acb*): audio callback
- bpm (float): beats per minute
- ins (Ins*[256]): instruments
- seq (Seq): sequencer
- pat (Pat*[4096]): patterns
- rfl (Rfl): register file
- sr (int): sample rate
- tpb (int): ticks per beat
- sng (Pla*): active song
- pse (Pla*): active phrases
- voc (Pla*): active voices
- bus (Pla*): active buses

## Audio engine

The audio subsystem of the OS periodically invokes the *audio callback* to fill a stereo audio buffer with 2^N sample frames. Typical values of N are between 6 and 10.

The audio callback has the following state variables:

- TPH: tick phase (double) - 0.0 <= TPH < 1.0
- FPT: sample frames per tick (double) = SR / ((BPM / 60) * TPB)
- REM: number of sample frames left to be filled in the audio buffer (int)
- NF: number of sample frames left to be filled for the current tick (double)
- INF: value of NF rounded to an integer
- TRA: reference to the tracker

TPH is initialized to zero when playback starts.

The tracker has references to all active voices, phrases and the song, so it can forward `tick` and `render` messages.

The audio callback implements the following algorithm:

```
1a. fill audio buffer with zeroes
1b. set REM = number of sample frames left to be filled in the audio buffer

2a. if REM == 0: exit
2b. if TPH == 0: invoke TRA.tick()
2c. set NF = FPT * (1 - TPH)
2d. if NF > REM: goto 4a

3a. set INF = round(NF)
3b. if INF > 0: invoke TRA.render(INF) and copy result into audio buffer
3c. set TPH = 0, REM -= INF
3d. goto 2a

4a. invoke TRA.render(REM) and copy result into audio buffer
4b. set TPH += REM/FPT
4c. exit
```

When the `TRA.render(N)` call returns, float arrays 0 and 1 of instrument 00 should contain the mixed output of all active voices. In other words, instrument programs shall be written such that their output is mixed (either directly or indirectly via a bus) into float arrays 0 and 1 of instrument 00.

## User interface

The following information is visible in the header row of all screens:

- BPM: beats per minute
- TPB: ticks per beat
- VOC: number of active voices
- CPU: CPU usage of audio callback (0-100%)

The following information is visible in the footer row of all screens:

- help for the currently focused item (instrument, trigger, register index, register value, opcode, opcode argument, edited value)

## Movement and selection in the sequencer and pattern editor

The cursor has a horizontal and vertical *scope*.

Horizontal scopes (h-scopes): character -> lane -> track/channel -> entire row/line
Vertical scopes (v-scopes): row/line (-> beat) -> entire column

By default, the h-scope is `character` and the v-scope is `row/line`.

By holding down Alt and pressing the arrow keys, the scope can be expanded either horizontally or vertically.

By holding down Shift and pressing the arrow keys, the scope can be extended (right/down) or shrinked (left/up) by one unit (where unit is the original size of the scope before any extension).

The arrow keys without any modifiers move the current scope around the matrix.

Tab and Shift+Tab moves to the next/previous sequencer track or pattern channel without changing the scope.

Pressing and releasing the Alt key restores the default scope.

When the h-scope is `character`, pressing [0-9A-F] enters the corresponding hex digit and moves the cursor in the current *advance direction*.

## Cut/copy/paste

- Ctrl+X: cut
- Ctrl+C: copy
- Ctrl+V: paste

## Global keyboard shortcuts

- F1: show help for the current context
- F2: switch to sequencer
- F3: switch to pattern editor
- F4: switch to instrument editor

- Space: play from marker / stop playing
- Esc: select widget

Widget selection works as follows: the user presses Esc, the UI shows a unique key on top of each selectable widget (widget selection mode). If the user presses one of the selector keys, the corresponding widget becomes focused and the user can edit it. Pressing Esc without choosing a widget leaves widget selection mode.

The sequencer and the pattern editor have their own markers. Switching to the sequencer makes the sequencer marker active. Switching patterns resets the pattern marker to line 0.
